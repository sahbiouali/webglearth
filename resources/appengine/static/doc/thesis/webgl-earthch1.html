<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->
<html xmlns="http://www.w3.org/1999/xhtml"
>
<head><title>1 Introduction</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" />
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" />
<!-- xhtml,2,fn-in,html -->
<meta name="src" content="webgl-earth.tex" />
<meta name="date" content="2011-09-13 15:42:00" />
<link rel="stylesheet" type="text/css" href="webgl-earth.css" />
</head><body
><!--l. 126--><div class="crosslinks"><p class="noindent">[<a
href="webgl-earthch2.html" >next</a>] [<a
href="#tailwebgl-earthch1.html">tail</a>] [<a
href="index.html#webgl-earthch1.html" >up</a>] </p></div>
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;1</span><br /><a
id="x2-10001"></a>Introduction</h2>
<!--l. 128--><p class="noindent" >Web applications are a very important platform because of their ability to
reach a large number of people easily. The ongoing advent of HTML5 and
WebGL opens a wide range of possibilities in all areas including Geographical
information systems (GIS). Three-dimensional visualizations of the Earth
are very modern-looking, popular, and allow us to display some attributes
(elevation data, 3D buildings, etc.) that can&#8217;t be shown with a classical top-down
view.
</p><!--l. 130--><p class="indent" >   Many web pages need to present some data to the visitors on a map
and sometimes even on a 3D model of the Earth. At the present time, the
only way to achieve such 3D visualization is by using <span
class="cmti-10">closed-source </span>Google
Earth API, which requires the installation of a browser extension. Many
users are not entitled to perform this kind of operation in the operating
system they&#8217;re using and need to ask a system administrator to install it for
them.
</p><!--l. 132--><p class="indent" >   The goal of the <span
class="cmti-10">WebGL Earth </span>project is to provide an alternative <span
class="cmti-10">open-source</span>
solution implemented in JavaScript and readily available in all WebGL-enabled
browsers. The result of this work is a platform-independent 3D application accessible
even with modern mobile devices (smartphones, tablets, etc.).
</p><!--l. 134--><p class="indent" >   The most technically challenging part of the visualization
process is the handling of very large textures (up to

2 billions&#x00A0;<span
class="cmsy-10">&#x00D7;</span>&#x00A0;2 billions pixels<span class="footnote-mark"><a
href="#fn1x1" id="fn1x1-bk"><sup class="textsuperscript">1</sup></a></span><a
id="x2-1001f1"></a>).
The existing solutions to this problem are described and analyzed in chapter&#x00A0;<a
href="webgl-earthch2.html#x3-80002">2<!--tex4ht:ref: chap:texturing --></a>. We
also describe new methods derived from these that are better suitable for our needs
and environment.
</p><!--l. 136--><p class="indent" >   The next part of this thesis (chapter&#x00A0;<a
href="webgl-earthch3.html#x4-150003">3<!--tex4ht:ref: chap:implementation --></a>) focuses on the actual implementation of
WebGL Earth and describes general project design and the inner workings of the
most important parts.
</p><!--l. 138--><p class="indent" >   This thesis is written in English so that it can serve as a &#8220;guide&#8221; to anyone who
would like to contribute to the WebGL Earth project or use it as a codebase for some
other project.
</p>
<h3 class="sectionHead"><span class="titlemark">1.1   </span> <a
id="x2-20001.1"></a>Existing virtual globes</h3>
<!--l. 141--><p class="noindent" >As we previously mentioned, there were no WebGL-based virtual globes that would
support zooming to street level at the time of writing this thesis, but there are
several standalone applications offering a wide variety of features that could serve as
an inspiration to the WebGL Earth project.
</p><!--l. 143--><p class="indent" >   One of the most popular and widely used virtual globes is <span
class="cmti-10">Google Earth</span>. It has a
lot of cutting-edge features like 3D terrain or buildings with photorealistic textures.
Google Earth also allows users to view a lot of different layers on top of the standard
map (state borders, weather overlays, traffic, etc.). One of the most important
features is the possibility to display the user&#8217;s own data in KML format, which
can contain placemarks, vector data, raster overlays or even 3D models.
It is, however, quite complicated to add a custom streamable tileset and
impossible to insert custom elevation data. Google Earth is <span
class="cmti-10">closed-source </span>and the
interface for user-created plugins is nonexistent. The main reason why Google
Earth is the most widely known virtual globe is probably its user-friendliness
(simple, but feature-rich UI or KML files opening with one click from the web
browser) and the Google Earth API for including 3D maps in a webpage via a
plugin.
</p><!--l. 145--><p class="indent" >   Another popular virtual globe is <span
class="cmti-10">NASA World Wind</span>. It has a similar set
of features as Google Earth, but it also has better support for user-added
content including elevation data and tile layers. NASA World Wind is an
<span
class="cmti-10">open-source</span>, community-driven project that has a lot of interesting features, but is
not as straight-forward to use as Google Earth for the typical computer
user.
</p><!--l. 147--><p class="indent" >   There are also many other virtual globes (osgEarth, Earth3D, Marble, etc.), but
they usually support similar features as the two mentioned above.
</p><!--l. 149--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">1.2   </span> <a
id="x2-30001.2"></a>HTML5 and canvas element</h3>
<!--l. 150--><p class="noindent" >HTML5 (HyperText Markup Language version 5) is a major revision of the standard

for presenting content on the Web. This revision introduces a number of new HTML
tags including the canvas element which allows for scriptable rendering of
pixel-based images through different contexts. At the time of writing this
thesis, there are two types of contexts available: <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">2d</span></span></span> and <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">webgl</span></span></span> (formerly
<span class="obeylines-h"><span class="verb"><span
class="cmtt-10">webgl-experimental</span></span></span>).
</p><!--l. 152--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">1.2.1   </span> <a
id="x2-40001.2.1"></a>2D context</h4>
<!--l. 153--><p class="noindent" >The first context type that was made widely available was <span
class="cmti-10">2D context</span>. It is designed
as a state machine (similarly to OpenGL) and can be used for high-performance
rendering of two-dimensional objects such as lines, rectangles, arcs, text or bitmap
images. The specification also defines methods for controlling shadow rendering or
creating gradient fills. The majority of modern web browsers already supports this
context type and most implementations are already GPU-accelerated (on certain
platforms).
</p><!--l. 155--><p class="indent" >   The 2D context can be (together with JavaScript) successfully used to
create interactive web visualizations or even web games right in the browser
itself.
</p><!--l. 157--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">1.2.2   </span> <a
id="x2-50001.2.2"></a>WebGL context</h4>
<!--l. 158--><p class="noindent" >The second context type enables web developers to create high-performance
three-dimensional presentations, which was previously possible only by using browser
plug-ins or extensions. The most significant disadvantage of this approach was that
the user had to have some additional (often proprietary) software installed (such as
Adobe Flash Player or Java Virtual Machine).
</p><!--l. 160--><p class="indent" >   WebGL context serves as a binding between high-level JavaScript and
low-level GPU operations. WebGL (Web-based Graphics Language) is based on
OpenGL ES 2.0 (Open Graphics Library for Embedded Systems) to be easily
implementable on modern mobile platforms such as Android or iOS (iPhone
OS).
</p><!--l. 162--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">1.3   </span> <a
id="x2-60001.3"></a>Graphics pipeline description</h3>
<!--l. 164--><p class="noindent" >In the past, graphics cards were operating in Fixed-Function Pipeline (FFP) mode
and programmers didn&#8217;t really have much control over the rendering process,
because most of the operations (geometry transformation, lightning, texture
sampling, etc.) were built into the hardware and could not be programmatically

changed.
</p><!--l. 166--><p class="indent" >   Modern GPUs use the so-called <span
class="cmti-10">Programmable Pipeline </span>(or Shader Pipeline)
which allows programmers to write special pieces of software (<span
class="cmti-10">shaders</span>) describing
behavior of the pipeline. This can be a very efficient way of creating various effects if
used properly. Modern graphics cards contain tens or even hundreds of stream
processors and follow the SIMD parallelism model (Single Instruction, Multiple
Data). As a result of this, shaders are executed optimally as long as they don&#8217;t
diverge on different data, so the programmer should try to avoid conditional and loop
statements if possible.
</p><!--l. 168--><p class="indent" >   WebGL is based on OpenGL ES 2.0 which supports <span
class="cmti-10">only </span>the Programmable
Pipeline (as opposed to OpenGL ES 1.1). The programming language used to write
shaders for OpenGL (and WebGL) is called GLSL (OpenGL Shading Language).
<br
class="newline" /><br
class="newline" /><br
class="newline" />Two types of shaders are supported in WebGL architecture:
</p><ol  class="enumerate1" >
<li
class="enumerate" id="x2-6002x1"><span
class="cmti-10">Vertex  shader  </span>is  a  program  that  is  executed  &#8220;per-vertex&#8221;  or,  more
generally, on each element of input data (<span
class="cmti-10">vertex attributes</span>). These data
<span
class="cmti-10">usually </span>consist of vertex positions, normal vectors, texturing coordinates,
etc., but there are no restrictions on input format or semantics. Practically
the only restriction is placed on the shader <span
class="cmti-10">output</span>. Every vertex shader
should write its calculation result (final vertex position in screen-space
coordinates) to the special variable called <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">gl_Position</span></span></span>.
</li>
<li
class="enumerate" id="x2-6004x2">As  a  part  of  the  rasterisation  process,  the  active  <span
class="cmti-10">fragment  shader  </span>is
executed to calculate the final color of each &#8220;fragment&#8221; (pixel) where the
currently rendered object is drawn and writes it into the <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">gl_FragColor</span></span></span>
variable. Fragment shaders can be used for simple texture sampling or to
create effects like bump mapping or dynamic shadows.</li></ol>
<!--l. 176--><p class="indent" >   When the vertex and fragment shaders are compiled and linked together we
sometimes refer to this assembly as the <span
class="cmti-10">shader program</span>.
</p>
<hr class="figure" /><div class="figure"
><a
id="x2-60051"></a>

<div class="center"
><!--l. 178--><p class="noindent" >
</p><!--l. 178--><p class="noindent" ><img
src="webgl-earth0x.png" alt="PIC" class="graphics" width="625.96062pt" height="311.94965pt"  /><!--tex4ht:graphics
name="webgl-earth0x.png" src="gfx/pipeline.eps"
-->
<br /> </p><div class="caption"
><span class="id">Figure&#x00A0;1.1: </span><span
class="content">WebGL pipeline and storage qualifiers</span></div><!--tex4ht:label?: x2-60051 -->
</div>

</div><hr class="endfigure" />
<!--l. 180--><p class="indent" >   A <span
class="cmti-10">storage qualifier </span>affects where a variable&#8217;s value originates, where it&#8217;s
stored, and what operations are allowed to be performed on it depending on
shader type. There are five different storage qualifiers in GLSL ES 1.0 [<a
href="webgl-earthli1.html#X0-GLSLES-Spec">Khr09</a>,
pp. 29&#8211;32]:
</p><ol  class="enumerate1" >
<li
class="enumerate" id="x2-6007x1">Local variables (default &#8211; no keyword)
</li>
<li
class="enumerate" id="x2-6009x2">Compile-time constants (keyword <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">const</span></span></span>)
</li>
<li
class="enumerate" id="x2-6011x3">The  previously  mentioned  vertex  attributes  used  to  input  per-vertex
data into the shader. The values of attribute variables are read-only and
accessible only from the vertex shader. (keyword <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">attribute</span></span></span>)
</li>
<li
class="enumerate" id="x2-6013x4">Uniform  variables  serving  as  &#8220;execution-time  constants&#8221;  that  do  not
change across the processed primitive. The values of uniform variables are
set via API commands and are read-only in both vertex and fragment
shaders. (keyword <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">uniform</span></span></span>)
</li>
<li
class="enumerate" id="x2-6015x5">The last storage qualifier forms a linkage between a vertex shader and
a fragment shader. The vertex shader calculates some per-vertex value
(color, texture coordinates, etc.) and writes it into the variable declared
with a <span
class="cmti-10">varying </span>qualifier. When a fragment shader reads from this variable,
the value it gets is a result of perspective-correct interpolation between
different values written to this variable on the vertices of the primitive
where the given fragment originated. (keyword <span class="obeylines-h"><span class="verb"><span
class="cmtt-10">varying</span></span></span>)</li></ol>
<!--l. 188--><p class="noindent" >Relationships between these storage qualifiers and shader types are illustrated by
figure&#x00A0;<a
href="#x2-60001.3">1.3<!--tex4ht:ref: fig:pipeline --></a>.
</p><!--l. 190--><p class="indent" >   It is very important to utilize the computational power of GPU interpolators
whenever possible &#8211; Many values can be calculated per-vertex with proper
interpolation subsequently available in the fragment shader saving some rendering
time as there is usually more pixels rendered than triangles in the processed
object.
</p><!--l. 192--><p class="indent" >   More information about this topic can be found in the <span
class="cmti-10">OpenGL Shading Language</span>
[<a
href="webgl-earthli1.html#X0-Rost-2006-GLSL">RK06</a>] or <span
class="cmti-10">OpenGL ES 2.0 Programming Guide </span>[<a
href="webgl-earthli1.html#X0-Munshi-2009-GLES">MGS09</a>].
</p>
<h3 class="sectionHead"><span class="titlemark">1.4   </span> <a
id="x2-70001.4"></a>Mercator projection</h3>
<!--l. 195--><p class="noindent" >There are many ways of projecting surface of the Earth to a plane. One of the most
popular is the Mercator projection, which is defined by the following equations,
where <span
class="cmmi-10">&#x03BB; </span>and <span
class="cmmi-10">&#x03C6; </span>are longitude and latitude and [<span
class="cmmi-10">x,</span><span style="margin-left:0.3em" class="thinspace"></span><span
class="cmmi-10">y</span>] are coordinates of the projected
point on the map:

</p><table
class="align">
<tr><td
class="align-odd"><span
class="cmmi-10">x</span></td>                         <td
class="align-even"> = <span
class="cmmi-10">&#x03BB;</span></td>                                                             <td
class="align-label"><a
id="x2-7001r1"></a>(1.1)
</td></tr><tr><td
class="align-odd"><span
class="cmmi-10">y</span></td>                         <td
class="align-even"> = sinh<sup><span
class="cmsy-7">-</span><span
class="cmr-7">1</span></sup>(tan(<span
class="cmmi-10">&#x03C6;</span>))</td>                                                  <td
class="align-label"><a
id="x2-7002r2"></a>(1.2)                         </td></tr></table>
<!--l. 201--><p class="indent" >   The principle of this projection is also often described as a balloon (representing
the Earth) placed inside a cylinder. The balloon then starts to &#8220;inflate&#8221; itself
occupying the volume of the cylinder. Unrolling the cylinder gives us the resulting
map.
</p><!--l. 203--><p class="indent" >   Meridians in the obtained coordinate system are regularly spaced, but the
distances between circles of latitude increase toward the poles to infinity.
</p>
<hr class="figure" /><div class="figure"
><a
id="x2-70032"></a>

<div class="center"
><!--l. 205--><p class="noindent" >
</p><!--l. 205--><p class="noindent" ><img
src="webgl-earth1x.png" alt="PIC" class="graphics" width="341.43306pt" height="341.43001pt"  /><!--tex4ht:graphics
name="webgl-earth1x.png" src="gfx/world_mercator_low.eps"
-->
<br /> </p><div class="caption"
><span class="id">Figure&#x00A0;1.2: </span><span
class="content">World map in Mercator projection</span></div><!--tex4ht:label?: x2-70032 -->
</div>

</div><hr class="endfigure" />
<!--l. 207--><p class="indent" >   As you can see in figure&#x00A0;<a
href="#x2-70001.4">1.4<!--tex4ht:ref: fig:world_mercator --></a>, the map preserves angles (which makes the
projection conformal) and shapes of small objects. However, the sizes of distant
objects are not comparable. For example, Greenland seems to be as large as
Africa.
</p><!--l. 209--><p class="indent" >   The Mercator projection is also incapable of displaying polar regions properly &#8211;
the poles themselves would be projected into infinity. Most world maps in this
projection are &#8220;cut off&#8221; at <span
class="cmmi-10">&#x03C6; </span>= <span
class="cmsy-10">±</span>85<span
class="cmmi-10">.</span>05113<sup><span
class="cmsy-7">&#x2218;</span></sup> so that the resulting map is square
shaped.
</p>
<hr class="figure" /><div class="figure"
><a
id="x2-70043"></a>

<div class="center"
><!--l. 211--><p class="noindent" >
</p><!--l. 211--><p class="noindent" ><img
src="webgl-earth2x.png" alt="PIC" class="graphics" width="341.43306pt" height="354.52257pt"  /><!--tex4ht:graphics
name="webgl-earth2x.png" src="gfx/mercator_tile_tree.eps"
-->
<br /> </p><div class="caption"
><span class="id">Figure&#x00A0;1.3: </span><span
class="content">Mercator tile pyramid</span></div><!--tex4ht:label?: x2-70043 -->
</div>

</div><hr class="endfigure" />
<!--l. 213--><p class="indent" >   This is very useful when we want to build the so-called &#8220;tile pyramid&#8221;
(figure&#x00A0;<a
href="#x2-70001.4">1.4<!--tex4ht:ref: fig:tile_pyramid --></a>), where each layer consists of four times more tiles than the previous one
while covering the same area. This means that each pixel in one level of pyramid is
replaced by four pixels in the next level giving twice as much detail in each
dimension.
</p><!--l. 215--><p class="indent" >   Tiles in each level are usually addressed from top-left corner (0<span
class="cmmi-10">,</span>0) to bottom-right
(2<sup><span
class="cmmi-7">n</span></sup> <span
class="cmsy-10">- </span>1<span
class="cmmi-10">,</span>2<sup><span
class="cmmi-7">n</span></sup> <span
class="cmsy-10">- </span>1). If we know the <span
class="cmti-10">tilekey</span> (<a
href="#x2-7005r3">1.3<!--tex4ht:ref: eq:tilekey --></a>) of the tile we need, we can easily
calculate the tilekey of the &#8220;fallback&#8221; tile (<a
href="#x2-7006r4">1.4<!--tex4ht:ref: eq:fallbacktilekey --></a>).
</p><!--l. 218--><p class="indent" >
</p><table
class="align">
<tr><td
class="align-odd"><span
class="cmmi-10">tilekey</span></td>                      <td
class="align-even"> = (<span
class="cmmi-10">zoom,x,y</span>)</td>                                        <td
class="align-label"><a
id="x2-7005r3"></a>(1.3)
</td></tr><tr><td
class="align-odd"><span
class="cmmi-10">fallbackTilekey</span></td>               <td
class="align-even"> = (<span
class="cmmi-10">zoom </span><span
class="cmsy-10">- </span>1<span
class="cmmi-10">,</span><span
class="cmsy-10">&#x230A;</span><span
class="cmmi-10">x&#x2215;</span>2<span
class="cmsy-10">&#x230B;</span><span
class="cmmi-10">,</span><span
class="cmsy-10">&#x230A;</span><span
class="cmmi-10">y&#x2215;</span>2<span
class="cmsy-10">&#x230B;</span>)</td>                              <td
class="align-label"><a
id="x2-7006r4"></a>(1.4)               </td></tr></table>
<!--l. 223--><p class="indent" >   Such <span
class="cmti-10">tilesets </span>(collections of images usually with the resolution of 256 <span
class="cmsy-10">&#x00D7; </span>256<span style="margin-left:0.3em" class="thinspace"></span>px) are
freely available from various projects such as <span
class="cmti-10">OpenStreetMaps </span>(up to level 18) or <span
class="cmti-10">Bing</span>
<span
class="cmti-10">Maps </span>(including aerial imagery). The same tile system is also used by many other
projects including the popular <span
class="cmti-10">Google Maps</span>.
</p><!--l. 225--><p class="indent" >   Interactive web maps are commonly using <span
class="cmti-10">Spherical Mercator </span>system which
uses Mercator projection on the sphere instead of WGS84 ellipsoid. [<a
href="webgl-earthli1.html#X0-Pridal-2008-TalGM">P&#x0159;i08</a>]
[<a
href="webgl-earthli1.html#X0-OLC-2011-SM">Ope08</a>]

</p>
<div class="footnotes"><!--l. 134--><p class="indent" >    <span class="footnote-mark"><a
href="#fn1x1-bk" id="fn1x1"><sup class="textsuperscript">1</sup></a></span><span
class="cmr-8">With 23 zoom levels and 256 </span><span
class="cmsy-8">&#x00D7; </span><span
class="cmr-8">256</span><span style="margin-left:0.3em" class="thinspace"></span><span
class="cmr-8">px</span> <span
class="cmr-8">tiles &#8212; (2</span><sup><span
class="cmr-6">23</span></sup> <span
class="cmsy-8">&#x00D7; </span><span
class="cmr-8">256)</span><sup><span
class="cmr-6">2</span></sup></p>                                       </div>
<!--l. 227--><div class="crosslinks"><p class="noindent">[<a
href="webgl-earthch2.html" >next</a>] [<a
href="webgl-earthch1.html" >front</a>] [<a
href="index.html#webgl-earthch1.html" >up</a>] </p></div>
<!--l. 227--><p class="indent" >   <a
id="tailwebgl-earthch1.html"></a>  </p>
</body></html>
